{"dependencies":[],"generated":{"js":"(function () {\n    const routers = [];\n\n    const applyRoutes = (a) => routers.map((router) => {\n        router.applyRoute(a)\n    })\n\n    var Route = function () {\n        this.route = arguments[0].route;\n        this.fn = arguments[0].fn;\n        this.scope = arguments[0].scope ? arguments[0].scope : null;\n        this.rules = arguments[0].rules ? arguments[0].rules : {};\n\n        this.routeArguments = Array();\n        this.optionalRouteArguments = Array();\n\n        //Create the route arguments if they exist\n        this.routeParts = this.route.split(\"/\");\n        for (var i = 0, j = this.routeParts.length; i < j; i++) {\n            var rPart = this.routeParts[i]\n\n            //See if there are pseudo macro's in the route\n\n            //will fetch all {id} parts of the route. So the manditory parts\n            if (rPart.substr(0, 1) == \"{\" && rPart.substr(rPart.length - 1, 1) == \"}\") {\n                var rKey = rPart.substr(1, rPart.length - 2);\n                this.optionalRouteArguments.push(rKey);\n            }\n            //will fetch all :id: parts of the route. So the optional parts\n            if (rPart.substr(0, 1) == \":\") {\n                var rKey = rPart.substr(1, rPart.length - 2);\n                this.routeArguments.push(rKey);\n            }\n        }\n    }\n    Route.prototype.matches = function (route) {\n        //We'd like to examen every individual part of the incoming route\n        var incomingRouteParts = route.split(\"/\");\n        //This might seem strange, but assuming the route is correct\n        //makes the logic easier, than assuming it is wrong.    \n        var routeMatches = true;\n        //if the route is shorter than the route we want to check it against we can immidiatly stop.\n        if (this.routeParts.slice(0, 2).indexOf('*') !== -1) routeMatches = true;\n        else if (incomingRouteParts.length < this.routeParts.length - this.optionalRouteArguments.length) {\n            routeMatches = false;\n            // console.log(1)\n        }\n        else {\n            // console.log(2)\n            let a = incomingRouteParts\n            for (var i = 0, j = a.length; i < j && routeMatches; i++) {\n                //Lets cache the variables, to prevent variable lookups by the javascript engine\n                var iRp = a[i];//current incoming Route Part\n                var rP = this.routeParts[i];//current routePart                     \n                if (typeof rP == 'undefined') {\n                    // console.log(20)\n                    //The route almost certainly doesn't match it's longer than the route to check against\n                    routeMatches = false;\n                }\n                else {\n                    // console.log(21)\n                    var cP0 = rP.substr(0, 1); //char at postion 0\n                    var cPe = rP.substr(rP.length - 1, 1);//char at last postion                   \n                    if ((cP0 != \"{\" && cP0 != \":\") && (cPe != \"}\")) {\n                        // console.log(210, cP0, cPe, rP, iRp, incomingRouteParts)\n                        //This part of the route to check against is not  a pseudo macro, so it has to match exactly\n                        if (iRp != rP) {\n                            routeMatches = false;\n                        }\n                    }\n                    else {\n                        // console.log(211)\n                        //Since this is a pseudo macro and there was a value at this place. The route is correct.\n                        routeMatches = true;\n                    }\n                }\n            }\n        }\n        // console.log(routeMatches, route, this)\n\n        return routeMatches;\n    }\n    Route.prototype.getArgumentsValues = function (route) {\n        //Split the incoming route\n        var rRouteParts = route.split(\"/\");\n        //Create an array for the values\n        var rArray = new Object();\n        for (var i = 0, j = this.routeParts.length; i < j; i++) {\n            var rP = this.routeParts[i];//current routePart\n            var cP0 = rP.substr(0, 1); //char at postion 0\n            var cPe = rP.substr(rP.length - 1, 1);//char at last postion\n            if ((cP0 == \"{\" && cPe == \"}\") || cP0 == \":\") {\n                let key = cP0 == \":\" ? rP.substr(1) : rP.substr(1, rP.length - 2)\n                // console.log(key, cP0 == \":\", rP.substr(1), rP.substr(1, rP.length - 2))\n                //if this part of the route was a pseudo macro,\n                //either manditory or optional add this to the array\n                rArray[key] = rRouteParts[i];\n            }\n        }\n        return rArray;\n    }\n    var Router = function ({routes, appId}) {\n        this.routes = new Array();\n        this.app = document.getElementById(appId);\n        if (!this.app) {\n            this.app = document.createElement('div')\n            this.app.id = appId\n            document.body.appendChild(this.app)\n        }\n        // console.log(routes)\n        routes.map(a => {\n            this.registerRoute(a.route, a.render)\n        })\n        routers.push(this)\n        this.applyRoute(window.location.pathname)\n        addEvent()\n    }\n    Router.prototype = {\n        //Here we use a somewhat different style of create the prototype\n        //than for the Route prototype. Both ways are valid. \n        //I'm using them mixed here, but It's probably wise not to do that.\n        //And stick to a single pattern. Here I'm doing it to show both possibilities\n        registerRoute: function (route, fn, paramObject) {\n            //We'll have route and function as named parameters\n            //and all the future optional parameters in a single object.\n            //Right now we just have scope as a optional parameters\n            var scope = paramObject && paramObject.scope || {};\n            return this.routes[this.routes.length] = new Route({\n                route: route,\n                fn: fn,\n                scope: scope\n            });\n        },\n        applyRoute: function (route) {\n            //iterate all routes\n            let matched = false\n            // console.log(route)\n            for (var i = 0, j = this.routes.length; i < j; i++) {\n                var sRoute = this.routes[i];\n                //match route\n                if (sRoute.matches(route)) {\n                    //if true call callback function with the proper scope\n                    let html = sRoute.fn.apply(sRoute.scope, [sRoute.getArgumentsValues(route), history, route]);\n                    this.app.innerHTML = html\n                    matched = true\n                    break;\n                }\n            }\n            if (!matched) {\n                this.app.innerHTML = '<h1>not found</h1>'\n                // console.log('nf')\n            }\n        },\n        changeRoute: function (r) {\n            r = r.split(window.location.origin).filter(a=> a)[0]\n            event.preventDefault()\n            applyRoutes(r)\n            history.pushState({}, r, r)\n            addEvent()\n            return false\n        },\n        goBack: function () {\n            event.preventDefault()\n            history.back()\n            return false\n        },\n        goForward: function (e) {\n            event.preventDefault()\n            history.forward()\n            return false\n        }\n    }\n\n    //We'll create an alias for router in the window object\n    window[\"Router\"] = Router;\n    window.onpopstate = (a) => {\n        applyRoutes(a.target.location.pathname)\n    }\n    window.onpushstate = (a) => {\n        applyRoutes(a.target.location.pathname)\n    }\n    const addEvent = () => {\n        if (routers.length) {\n            const links = document.getElementsByClassName('router-link')\n            for (let i = 0; i< links.length; i++) {\n                links[i].onclick = () => routers[0].changeRoute(links[i].href)\n            }\n        }\n        else throw new Error('No Router Spacified')\n    } \n    // <a href=\"javascript:void(0)\" onclick=\"history.back()\">('back')</a>\n    // <a href=\"javascript:void(0)\" onclick=\"history.forward()\">('forward')</a>\n    // router.applyRoute(window.location.pathname)\n})();\n"},"hash":"f2a22a9fa4037d19d1432e2e9b9a0730"}